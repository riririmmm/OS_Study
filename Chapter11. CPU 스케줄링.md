## 11-1. CPU 스케줄링 개요

- **CPU 스케줄링**: 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것
- **우선순위**: 빨리 처리해줘야 하는 프로세스의 순위
    - 운영체제는 프로세스마다 PCB에 우선순위 명시, 이 기준으로 먼저 처리할 프로세스 결정
- **입출력 집중 프로세스**: 입출력 작업이 많은 프로세스(ex. 비디오 재생, 디스크 백업 작업 담당)
    - 실행 상태보다 입출력을 위한 대기 상태에 더 많이 머무름
- **CPU 집중 프로세스**: CPU 작업이 많은 프로세스(ex. 복잡한 수학 연산, 컴파일, 그래픽 처리 작업 담당)
    - 대기 상태보다 실행 상태에 더 많이 머무름
    - 모든 프로세스가 CPU를 차례로 돌아가며 사용하는 것보다 각각의 상황에 맞게 CPU를 배분하는 것이 더 효율적
- 프로세스는 일반적으로 CPU 버스트와 입출력 버스트를 반복하며 실행됨
    - **CPU 버스트**: CPU를 이용하는 작업
    - **입출력 버스트**: 입출력장치를 기다리는 작업
- 프로세스들의 자원 요청을 **스케줄링 큐**로 관리
    - **준비 큐**: CPU를 이용하고 싶은 프로세스들이 서는 줄
    - **대기 큐**: 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄
    
    <img width=65% src="https://github.com/user-attachments/assets/1ad1bc1a-e37f-40ad-bada-9ccdd5de7242" />

    
    - 상태 다이어그램
        
        <img width=65% src="https://github.com/user-attachments/assets/48879155-bdf1-4d96-ba2f-915df0e65229" />

        
- **선점형 스케줄링**: 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당 가능한 스케줄링
    - 장점: 어느 한 프로세스의 자원 독점 방지, 프로세스들에 골고루 자원 배분 가능
    - 단점: 문맥 교환 과정에서 오버헤드 발생 가능
- **비선점형 스케줄링**: 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료 / 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링
    - 장점: 문맥 교환에서 발생하는 오버헤드 적음
    - 단점: 모든 프로세스가 골고루 자원 사용 불가능

### 확인 문제

- #1. 프로세스 스케줄링에 대해 옳지 않은 것을 고르세요.
    1. 운영체제는 우선순위를 토대로 프로세스들을 스케줄링합니다.
    2. 운영체제는 스케줄링 큐를 사용하여 스케줄링할 프로세스들을 관리합니다.
    3. 준비 큐에는 준비 상태인 프로세스들이, 대기 큐에는 대기 상태인 프로세스들이 삽입됩니다.
    4. 선점형 스케줄링은 프로세스가 이용 중인 자원을 빼앗을 수 없는 방식을 의미합니다.
    - 정답: 4번
- #2. ①과 ②에 알맞은 말을 써넣으세요.
    
    <img width=65% alt="image" src="https://github.com/user-attachments/assets/d8085409-8b5f-4261-aa93-beecc2639d6e" />

    
    - 정답: ① 준비큐, ② 대기 큐
- #3. 선점형 스케줄링과 비선점형 스케줄링에 대해 옳지 않은 것을 고르세요.
    1. 선점형 스케줄링은 어느 한 프로세스가 자원을 독점할 수 없는 스케줄링 방식입니다.
    2. 선점형 스케줄링은 문맥 교환 과정의 오버헤드가 비선점형 스케줄링에 비해 적습니다.
    3. 비선점형 스케줄링은 어느 한 프로세스가 자원을 독점할 수 있는 스케줄링 방식입니다.
    4. 비선점형 스케줄링은 문맥 교환 과정의 오버헤드가 선점형 스케줄링에 비해 적습니다.
    - 정답: 2번

## 11-2. CPU 스케줄링 알고리즘

- **선입 선처리 스케줄링**(**FCFS 스케줄링**)
준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링
    - 프로세스들이 기다리는 시간이 매우 길어질 수 있음
    - **호위 효과**: 긴 프로세스가 CPU를 독점하여 다른 짧은 프로세스들이 대기하는 시간이 길어지는 현상
- **최단 작업 우선 스케줄링**(**SJF 스케줄링**)
    - 준비 큐에 삽입된 프로세스들 중 CPU 이용 사긴의 길이가 가장 짧은 프로세스부터 실행하는 비선점형 스케줄링
- **라운드 로빈 스케줄링**
    - 선입 선처리 스케줄링 + 타임 슬라이스
    - **타임 슬라이스**: 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
    - 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU 이용하는 선점형 스케줄링
    - 타임 슬라이스 크기 중요
- **최소 잔여 시간 우선 스케줄링**(**SRT 스케줄링**)
    - 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
    - 최서 잔여 시간 우선 스케줄링에서 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스는 남아있는 작업 시간 가장 적은 프로세스 선택
- **우선순위 스케줄링**
    - 프로세스들에 우선순위 부여, 가장 높은 우선순위를 가진 프로세스부터 실행하는 알고리즘
    - 우선순위 같으면 선입 선처리
    - 기아 현상 발생 가능
        - **기아 현상**: 우선순위 높은 프로세스에 의해 우선순위 낮은 프로세스의 실행이 계속해서 연기되는 현상
    - 기아 현상 방지 위한 기법으로 에이징 사용
        - **에이징**: 오랫동안 대기한 프로세스의 우선순위를 점차 높임
- **다단계 큐 스케줄링**
    - 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식
    - 우선순위가 가장 높은 큐에 있는 프로세스 먼저 처리, 해당 큐 비면 그 다음 우선순위 큐 프로세스 처리
    - 큐별로 타임 슬라이스 / 알고리즘 각각 지정 가능
    - 기아 현상 발생 가능
- **다단계 피드백 큐 스케줄링**
    - 프로세스들이 큐 사이 이동 가능
    - 다단계 피드백 큐 스케줄링에서 새로 준비 상태가 된 프로세스: 우선 순위 가장 높은 우선순위 큐에 삽입, 일정 시간(타임 슬라이스) 동안 실행
    - 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행
    - 위 과정 반복
    - ⇒ CPU 집중 프로세스들 우선순위 ↓, 입출력 집중 프로세스들 우선순위 ↑
    - 에이징 기법 적용으로 기아 현상 예방 가능
    
    <img width=65% src="https://github.com/user-attachments/assets/e5b0b40f-565f-433f-bd35-b9d90743d114" />

    

### 확인 문제

- #1. 준비 큐에 프로세스 A, B, C, D 순으로 삽입되었다고 가정했을 때, 선입 선처리 스케줄링 알고리즘을 적용한다면 어떤 프로세스 순서대로 CPU를 할당받게 될까요?
    1. A-D-B-C
    2. B-C-A-D
    3. A-B-C-D
    4. D-C-B-A
    - 정답: 3번
- #2. 다음 보기에서 올바른 정의를 찾아 써 보세요.
    
    > `보기` 기아 현상, 에이징, 타임 슬라이스
    > 
    - 우선순위가 낮아 실행이 계속 연기되는 문제를 무엇이라고 하나요? (   ①   )
    - 우선순위가 낮아 실행이 계속 연기되는 문제를 해결하기 위해 점차 우선순위를 높이는 기법을 무엇이라고 하나요? (   ②   )
    - 정답: ① 기아 현상, ② 에이징
