## 10-1. 프로세스 개요

- **프로세스**: 실행 중인 프로그램
    - ‘프로세스 생성’: 보조기억장치에 있는 데이터 덩어리의 프로그램을 메모리에 적재하고 실행함
    - **포그라운드 프로세스**: 사용자가 볼 수 있는 공간에서 실행되는 프로세스
    - **백그라운드 프로세스**: 사용자기 볼 수 없는 공간에서 실행되는 프로세스
        - 데몬(유닉스) / 서비스(윈도우): 사용자와 상호작용하지 않는 백그라운드 프로세스
- **프로세스 제어 블록**(**PCB**; Process Control Block)
    - 프로세스 관련 정보 저장하는 자료 구조
    - 커널 영역에서 생성
    - 프로세스의 생명 주기를 함께함
    - PCB에 담기는 정보
        - **프로세스 ID**(PID): 특정 프로세스를 식별하기 위해 부여하는 고유한 번호
        - 레지스터 값: 해당 프로세스가 실행하며 사용했던 프로그램 카운터를 비롯한 레지스터 값들 저장
        - 프로세스 상태: 프로세스 상태(ex. IO 사용 대기, CPU 이용 중) 저장
        - CPU 스케줄링 정보: 프로세스의 CPU 할당 정보 저장
        - 메모리 정보 관리: 프로세스가 어느 주소에 저장되어 있는지, 베이스 레지스터, 한계 레지스터 값과 같은 정보 등 저장
        - 사용한 파일 & 입출력장치 목록: 사용한 입출력장치 / 파일 정보 저장
- **문맥**: 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보
- **문맥 교환**: 기존 프로세스 문맥을 PCB에 백업, 새로운 프로세스 실행 위한 문맥을 PCB로부터 복구하여 새로운 프로세스 실행
    - 문맥 교환 자주 발생 → 프로세스 동시 실행처럼 보임
    - but 너무 자주 하면 오버헤드 발생 가능
- 프로세스 메모리 영역
    - **코드 영역** / **데이터 영역** / **힙 영역** / **스택 영역**
        
        
        <img width="80%" alt="Image" src="https://github.com/user-attachments/assets/9ee9346e-ca4c-4f41-9b99-b3286dd5266d" />
        
    - 코드 영역(텍스트 영역)
        - 실행 가능한 코드(기계어로 이루어진 명령어) 저장
        - 읽기 전용 공간
        - **정적 할당 영역**: 크기 고정 영역
    - 데이터 영역
        - 프로그램 실행 동안 유지할 데이터(ex. **전역 변수**) 저장 공간
        - 정적 할당 영역
    - 힙 영역
        - 프로그래머가 직접 할당 가능한 저장 공간
        - **메모리 누수**: 메모리 공간 할당 후 공간을 반환하지 않아 초래되는 메모리 낭비
        - **동적 할당 영역**: 크기 가변 영역
        - 메모리의 낮은 주소 → 높은 주소 할당
    - 스택 영역
        - 데이터(ex. 지역변수)를 일시적으로 저장하는 공간
        - 동적 할당 영역
        - 높은 주소 → 낮은 주소 할당

### 확인 문제

- #1. 프로세스와 관련한 설명 중 옳지 않은 것을 고르세요.
    1. 실행되는 프로그램을 프로세스라고 합니다.
    2. 프로세스가 생성되면 커널 영역에 PCB가 생성됩니다.
    3. 프로세스들은 문맥 교환을 통해 번갈아 가며 수행됩니다.
    4. 프로세스는 반드시 사용자와 상호작용할 수 있어야 합니다.
    - 정답: 4번
- #2. 문맥 교환과 관련한 설명 중 옳지 않은 것을 고르세요.
    1. 문맥 교환은 자주 수행될수록 좋습니다.
    2. 문맥 교환 과정에서 직전에 수행되던 프로세스의 문맥이 백업됩니다.
    3. 문맥 교환 과정에서 다음에 수행할 프로세스의 문맥이 복구됩니다.
    4. 문맥은 PCB에 기록됩니다.
    - 답: 1번

## 10-2. 프로세스 상태와 계층 구조

- 프로세스 상태
    - **생성 상태**
        - 프로세스 생성 중인 상태
        - 메모리에 적재되어 PCB 할당 받음
    - **준비 상태**
        - 바로 CPU를 할당받아 실행 가능하지만 차례가 아니어서 대기 중인 상태
        - **디스패치**: 준비 상태의 프로세스가 실행 상태로 전환되는 것
    - **실행 상태**
        - CPU를 할당받아 실행 중인 상태
        - 타이머 인터럽트 발생 시 다시 준비 상태 됨
        - 실행 도중 입출력장치 사용하여 입출력장치 작업 끝날 때까지 기다려야 하면 대기 상태 됨
    - **대기 상태**
        - 특정 이벤트가 일어나길 기다리는 상태
        - CPU에 비해 처리 속도가 느린 입출력 장치 작업이 끝나기를 기다리는 상태
        - 입출력 작업 완료 시 다시 준비 상태로 복귀
    - **종료 상태**
        - 프로세스 종료된 상태
        - 종료 시 PCB와 프로세스가 사용한 메모리 정리
- **프로세스 상태 다이어그램**
    
    <img width="65%" alt="Image" src="https://github.com/user-attachments/assets/a34d4584-4596-464f-9734-9bf0feb73d8b" />
    
- **부모 프로세스**: 새 프로세스를 생성한 프로세스
- **자식 프로세스**: 부모 프로세스에 의해 생성된 프로세스
- **프로세스 계층 구조**: 컴퓨터 부팅 시 실행되는 최초의 프로세스가 자식 프로세스를 생성하고, 생성된 자식 프로세스들이 새로운 프로세스들을 낳는 트리 구조
    
    <img width="65%" alt="Image" src="https://github.com/user-attachments/assets/6b88ac44-6643-46f7-88e8-1c749923e5b9" />
    
- 프로세스 생성 기법
    - 부모 프로세스는 **fork**를 통해 자신의 본사본을 자식 프로세스로 생성
    - 만들어진 복사본(자식 프로세스)는 **exec**를 통해 자신의 메모리 공간을 다른 프로그램으로 교체
- fork & exec
    - fork
        - 자기 자신 프로세스의 복사본 만드는 시스템 호출
        - 자식 프로세스는 부모 프로세스의 자원(ex. 메모리 내용, 열린 파일 목록) 상속
        - 복사된 자식 프로세스라 하더라도 PID / 저장된 메모리 위치는 다름
    - exec
        - 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출

### 확인 문제

- #1. 다음은 프로세스 상태를 보여주는 프로세스 상태 다이어그램입니다. ①부터 ⑤까지 올바른 상태를 적어 보세요.
    
    <img width="65%" alt="Image" src="https://github.com/user-attachments/assets/ca251c48-45a8-423b-88d6-6b32e8f86c8a" />
    
    - 정답: 생성 상태, 준비 상태, 실행 상태, 종료 상태, 대기 상태
- #2. 최초 프로세스가 로그인 프로세스를 생성하고, 로그인 프로세스는 bash 프로세스를, bash 프로세스는 Vim 프로세스를 생성했다고 가정해 보겠습니다
    - bash 프로세스의 부모 프로세스는 무엇인가요?
        - 정답: 로그인 프로세스
    - bash 프로세스의 자식 프로세는 무엇인가요?
        - 정답: Vim 프로세스
    - Vim 프로세스의 부모 프로세스는 무엇인가요?
        - 정답: bash 프로세스
- #3. fork와 exec에 대한 설명으로 옳지 않은 것을 고르세요.
    1. fork 시스템 호출을 하면 새로운 폴더가 생성됩니다.
    2. fork 시스템 호출을 하면 부모 프로세스의 복제본이 자식 프로세스로서 생성됩니다.
    3. exec 시스템 포출을 하면 프로세스의 메모리 공간이 다른 프로세스의 내용으로 변경됩니다.
    4. 많은 운영체제는 fork와 exec을 통해 프로세스 계층 구조를 형성합니다.
    - 정답: 1번
- #4. 프로세스 상태에 대한 설명으로 옳은 것을 고르세요.
    1. 생성 상태는 프로세스가 입출력 장치의 작업을 기다리는 상태입니다.
    2. 실행 상태는 프로세스가 종료되는 상태입니다.
    3. 종료 상태는 프로세스가 이제 막 생성된 상태입니다.
    4. 준비 상태는 CPU를 할당받기를 기다리고 있는 상태입니다.
    - 정답: 4번

## 10-3. 스레드

- **스레드**: 프로세스를 구성하는 실행의 흐름 단위
    - 하나의 프로세스는 여러 개의 스레드 가질 수 있음
    - **단일 스레드 프로세스**: 프로세스가 하나의 실행 흐름을 갖고 한 번에 하나의 부분만 실행
    - **멀티 스레드 프로세스**: 하나의 프로세스가 한 번에 여러 일을 동시에 처리할 수 있음
    - 프로세스 내에서 각기 다른 스레드 ID, 레지스터 값, 스택으로 구성
    - 실행에 필요한 최소한의 정보(레지스터, 스택) 유지한 채 프로세스 자원 공유하며 실행
- **멀티 프로세스**: 여러 프로세스를 동시에 실행하는 것
    - 프로세스끼리 자원 공유X
    - PID, 저장된 메모리 주소 제외 모든 것이 동일한 프로세스 n개가 통째로 메모리에 적재
        - ⇒ 메모리 낭비
    - 독립적 실행
    ⇒ 하나의 프로세스에 문제 생겨도 다른 프로세스 지장X
    
    <img width="65%" alt="Image" src="https://github.com/user-attachments/assets/597fe317-aa98-4bfe-8ca1-44f1bb7e029b" />
    
- **멀티스레드**: 여러 스레드로 프로세스를 동시에 실행하는 것
    - 스레드끼리 같은 프로세스 내 자원 공유O
    - 각기 다른 스레드 ID, 레지스터 값, 스택 가지고 프로세스의 자원 공유
    - 협력과 통신에 유리
    - but 하나의 스레드에 문제 생기면 다른 스레드에도 영향
    
    <img width="65%" alt="Image" src="https://github.com/user-attachments/assets/2df2abe2-e909-4811-9c05-6a8de4ed914a" />
    
- **프로세스 간 통신**(**IPC**; Inter-Process Communication)
    - 프로세스끼리 자원 공유 & 데이터 주고받는 것
    - 파일을 통한 프로세스 간 통신: A 프로세스가 파일 쓰고 B 프로세스가 그 데이터를 읽음
    - **공유 메모리**: 프로세스 간 데이터 주고받을 수 있도록 하는 공유하는 메모리 영역

### 확인 문제

- #1. 스레드와 관련한 설명으로 옳지 않은 것을 고르세요.
    1. 스레드는 프로세스 내의 실행 흐름 단위입니다.
    2. 프로세스 내의 스레드들은 각기 다른 코드 / 데이터 / 힙 영역을 가지고 있습니다.
    3. 프로세스 내의 스레드들은 각기 다른 프로그램 카운터값을 가지고 있습니다.
    4. 프로세스 내의 스레드들은 각기 다른 스택을 가지고 있습니다.
    - 정답: 2번
- #2. 멀티프로세스와 멀티스레드의 차이를 설명하는 내용입니다. 아래 글에서 제시된 단어 중 옳은 것을 고르세요.
    
    > 프로세스끼리는 기본적으로 자원을 (공유하지 않지만, 공유하지만), 프로세스 내의 스레드끼리는 같은 프로세스 내의 자원을 (공유하지 않습니다, 공유합니다).
    > 
    - 정답: 공유하지 않지만, 공유합니다.
