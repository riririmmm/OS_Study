## 04-1. ALU와 제어장치

- **ALU**
    
    <img width=65% alt="image" src="https://github.com/user-attachments/assets/4f5f2831-a74a-494f-bcfd-a9eea5ddcc4a" />

    
    - 레지스터를 통해 **피연산자**를, 제어장치로부터 수행할 연산을 알려주는 **제어 신호** 받아들임
    - ALU가 내보내는 것
        - 계산 결괏값
        - **플래그**
            
            
            | 플래그 종류 | 의미 | 사용 예시 |
            | --- | --- | --- |
            | 부호 플래그 | 연산한 결과의 부호를 나타냄 | 부호 플래그가 1일 경우 계산 결과 음수, 0일 경우 계산 결과 양수 |
            | 제로 플래그 | 연산 결과가 0인지 여부 나타냄 | 제로 플래그가 1일 경우 연산 결과 0, 0일 경우 연산 결과 0 아님 |
            | 캐리 플래그 | 연산 결과 올림수 / 빌림수 발생 여부 표시 | 캐리 플래그 1일 경우 올림수 / 빌림수 발생O, 0일 경우 발생X 의미 |
            | 오버플로우 플래그 | 오버플로우가 발생했는지 표시 | 오버플로우 플래그 1일 경우 오버플로우 발생O, 0일 경우 발생X 의미 |
            | 인터럽트 플래그 | 인터럽트 가능한지 표시 | 인터럽트 플래그 1일 경우 인터럽트 가능, 0일 경우 인터럽트 불가능 의미 |
            | 슈퍼바이저 플래그 | 커널 모드 / 사용자 모드 실행 중인지 표시 | 슈퍼바이저 플래그가 1일 경우 커널 모드로, 0일 경우 사용자 모드로 실행 중 |
            - **플래그 레지스터**: 플래그 저장하는 레지스터
- **제어 장치**: 제어 신호 내보내고 명령어 해석하는 부품
    - **제어 신호**: 컴퓨터 부품 관리 & 작동 위한 일종의 전기 신호
    
    <img width=65% alt="image" src="https://github.com/user-attachments/assets/5c998fac-a746-4bc5-9479-9f6d591ec755" />

    
    - 제어장치가 받는 정보
        - **클럭 신호**
            - 컴퓨터의 부품을 동기화시키는 시간 단위
        - 해석해야 할 명령어
            - 명령어 받아 *명령어 레지스터*에 저장
        - 플래그 레지스터 속 플래그
        - 시스템 버스 중 제어 버스로 전달된 제어 신호
    - 제어장치가 내보내는 정보
        - CPU 외부에 전달하는 제어 신호
            - 제어 버스로 제어 신호 내보냄
            - 메모리 전달하는 제어 신호 / 입출력 전달하는 제어 신호
        - CPU 내부에 전달하는 제어 신호
            - ALU에 전달하는 제어 신호 / 레지스터에 전달하는 제어 신호

### 확인 문제

- #1. 아래와 같은 플래그 레지스터를 가진 CPU가 있다고 가정해 봅시다. 이 CPU의 ALU가 연산한 결과가 다음과 같을 때 계산 결과를 십진수로 말해 보세요.
    
    <img width=65% alt="image" src="https://github.com/user-attachments/assets/826ba700-dbd6-4390-9ee4-8e9e9a66746c" />

    
    - 정답: -3
- #2. 다음 중 제어장치와 관련된 설명 중 옳지 않은 것을 고르세요.
    1. 제어장치는 제어 버스로 제어 신호를 내보냅니다.
    2. 제어장치는 제어 신호를 통해 ALU에게 연산을 지시합니다.
    3. 제어장치는 클럭 신호를 받아들입니다.
    4. 제어장치는 CPU 내에서 산술연산과 논리연산을 담당하는 부품입니다.
    - 정답: 4번
- #3. 아래 그림에서 ①, ②, ③에 들어갈 알맞은 단어를 채워 보세요.
    
    <img width=65% alt="image" src="https://github.com/user-attachments/assets/8fd9fab2-75ae-48f3-a634-1fc50252f4c6" />

    
    - 정답: ① 플래그 레지스터, ② 명령어 레지스터, ③ 제어 버스
- #4. CPU의 구성 요소로 적절하지 않은 것을 고르세요.
    1. ALU
    2. 레지스터
    3. 제어장치
    4. 하드 디스크
    - 정답: 4번

## 04-2. 레지스터

- **프로그램 카운터**
    - 메모리에서 읽어 들일 명령어의 주소 저장
    - *명령어 포인터*라고 부르기도 함
- **명령어 레지스터**
    - 해석할 명령어(방금 메모리에서 읽어 들인 명령어)를 저장하는 레지스터
- **메모리 주소 레지스터**
    - 메모리 주소를 저장하는 레지스터
    - CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터 거침
- **메모리 버퍼 레지스터**
    - 메모리와 주고받을 값(데이터 & 명령어) 저장하는 레지스터
    - *메모리 데이터 레지스터(MDR)* 라고도 부름
- 메모리에 저장된 프로그램을 실행하는 과정
    1. CPU로 실행할 프로그램이 1000 ~ 1500번지까지 저장됨 가정. 1000번지에 1101(2) 저장 가정.
    2. 프로그램을 처음부터 실행 위해 프로그램 카운터에 1000 저장. 이는 메모리에서 가져올 명령어가 1000번지에 있다는 걸 의미.
    3. 1000번지를 읽어 들이기 위해 주소 버스로 1000번지 내보내야 함. 이를 위해 메모리 주소 레지스터에 1000 저장.
    4. ‘메모리 읽기’ 제어 신호 & 메모리 주소 레지스터 값이 각각 제어 버스 & 주소 버스 통해 메모리로 보내짐
    5. 메모리 1000번지에 저장된 값: 데이터 버스 통해 메모리 버퍼 레지스터로 전달, 프로그램 카운터 증가 → 다음 명령어 읽어 들일 준비
    6. 메모리 버퍼 레지스터에 저장된 값 → 명령어 레지스터로 이동
    7. 제어 장치: 명령어 레지스터의 명령어를 해석 & 제어 신호 발생
- **범용 레지스터**
    - 다양하고 일반적인 상황에서 자유롭게 사용 가능한 레지스터
    - 데이터 & 주소 모두 저장 가능
- **플래그 레지스터**
    - 연산 결과 or CPU 상태에 대한 부가적인 정보 저장
- 특정 레지스터를 이용한 주소 지정 방식 (1): **스택 주소 지정 방식**
    - 스택 & 스택 포인터를 이용한 주소 지정 방식
    - **스택 포인터**: 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터
- 특정 레지스터를 이용한 주소 지정 방식 (2): **변위 주소 지정 방식**
    - 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식
    - 명령어 = 연산 코드 + 레지스터 + 오퍼랜드
    - 오퍼랜드 필드의 주소 & 어떤 레지스터 더하는지에 따라 *상대 주소 지정 방식* / *베이스 레지스터 주소 지정 방식* 등으로 나뉨
    - **상대 주소 지정 방식**
        - 오퍼랜드 & 프로그램 카운터 값 더하여 유효 주소 얻는 방식
    - **베이스 레지스터 주소 지정 방식**
        - 오퍼랜드(기준 주소로부터 떨어진 거리) & 베이스 레지스터(기준 주소) 값 더하여 유효 주소 얻는 방식

### 확인 문제

- #1. 현재 프로그램 카운터에 저장된 값이 아래와 같을 때 CPU가 다음으로 읽어 들일 메모리 주소는 몇 번지일까요?
    
    <img width=40% alt="image" src="https://github.com/user-attachments/assets/079a910f-2398-49f8-9eea-670683b12368" />

    
    - 정답: 2100번지
- #2. 설명에 맞는 레지스터를 보기에서 찾아 빈칸을 채워 보세요.
    
    > `보기` 프로그램 카운터, 명령어 레지스터, 플래그 레지스터, 범용 레지스터
    > 
    - (   ①   ): 연산 결과 혹은 CPU 상태에 대한 부가 정보를 저장하는 레지스터
    - (   ②   ): 메모리에서 가져올 명령어의 주소를 저장하는 레지스터
    - (   ③   ): 데이터와 주소를 모두 저장할 수 있는 레지스터
    - (   ④   ): 해석할 명령어를 저장하는 레지스터
    - 정답: ① 플래그 레지스터, ② 프로그램 카운터, ③ 범용 레지스터, ④ 명령어 레지스터
- #3. 현재 아래와 같은 스택을 가리키는 스택 포인터가 있다고 가정해 봅시다. 이 스택에서 데이터를 두 번 빼내게 되었을 때 스택 포인터에 저장되는 주소는 몇 번지일까요?
    
    <img width=65% alt="image" src="https://github.com/user-attachments/assets/a6d2e1d4-19c0-4640-b93b-60a344c52e17" />

    
    - 정답: 6번지
- #4. 레지스터에 대한 설명으로 옳은 것을 고르세요.
    1. 산술 연산과 논리 연산을 수행하는 부품입니다.
    2. 제어 신호를 발생시킵니다.
    3. 명령어를 해석합니다.
    4. CPU 내에 있는 작은 임시 저장 장치입니다.
    - 정답: 4번

## 04-3. 명령어 사이클과 인터럽트

- **명령어 사이클**: 하나의 명령어를 처리하는 정형화된 흐름
    - **인출 사이클**: 메모리에 있는 명령어를 CPU로 가지고 오는 단계
    - **실행 사이클**: CPU로 가져온 명령어를 실행하는 단계.
        - 제어 장치가 명령어 레지스터에 담긴 값을 해석, 제어 신호 발생
    - **간접 사이클**: 간접 주소 지정 방식 시 명령어 실행 위해 메모리 접근 한 번 더 해야함
    
    <img width=65% alt="image" src="https://github.com/user-attachments/assets/bc68e368-a8c0-4a09-b399-7edd80387828" />

    
- **인터럽트**: CPU의 정상적인 작업을 방해하는 신호
    - **동기 인터럽트**: CPU에 의해 발생하는 인터럽트
        - ex) CPU가 실행하는 프로그래밍 상의 오류와 같은 예외적인상황에서 발생하는 인터럽트
        - *예외*라고도 부름
    - **비동기 인터럽트**: 입출력 장치에 의해 발생하는 인터럽트
        - ex) CPU가 입출력장치에 입출력 작업 부탁 시 작업 끝낸 IO가 CPU에 완료 알림(인터럽트) 보냄
        - *하드웨어 인터럽트*라고도 함
- **하드웨어 인터럽트**
    - CPU 입출력 작업 도중에도 효율적으로 명령어 처리 위해 하드웨어 인터럽트 사용
    - 처리 순서
        1. 입출력장치: CPU에 *인터럽트 요청 신호* 전송
        2. CPU: 실행 사이클 종료 후 명령어 인출 전 항상 인터럽트 여부 확인
        3. CPU: 인터럽트 요청 확인 후 *인터럽트 플래그* 통해 현재 인터럽트 받을 수 있는지 여부 확인
        4. 인터럽트 받을 수 있다면 CPU 작업 백업
        5. *인터럽트 벡터* 참조하여 *인터럽트 서비스 루틴* 실행
        6. 인터럽트 서비르 수틴 실행 끝나면 (4)에서 백엄해 둔 작업 복구 & 실행 재개
    - **인터럽트 요청 신호**: 인터럽트 가능 여부를 묻는 신호
    - **인터럽트 플래그**: 인터럽트 요청 수용 위해 인터럽트 플래그 활성화 필요
        - 인터럽트 플래그 불가능이어도 무시 불가능한 인터럽트를 **막을 수 없는 인터럽트**라 함
    - **인터럽트 서비스 루틴**: 인터럽트 처리 위한 프로그램
        - *인터럽트 핸들러*라고도 부름
        - 인터럽트 발생 시 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어짐
        
        <img width=65% alt="image" src="https://github.com/user-attachments/assets/4bc50498-091c-4d37-99de-70a1578bf250" />

        
- **인터럽트 벡터**: 인터럽드 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보
- 예외의 종류
    - **폴트**: 예외를 처리한 직후 예외가 발생한 명령어로부터 실행 재개
    - **트랩**: 예외 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행 재개
        - 주로 디버깅에 사용
    - **중단**: CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류 발견 시 발생
    - **소프트웨어 인터럽트**: 시스템 호출 발생 시 나타남

### 확인 문제

- #1. 명령어 사이클에 대한 설명으로 옳지 않은 것을 고르세요.
    1. 명령어 사이클은 인출, 간접, 실행, 인터럽트 사이클로 구성됩니다.
    2. 인출 사이클은 메모리에서 실행할 명령어를 CPU로 가져오는 과정을 의미합니다.
    3. 간접 사이클은 피연산자의 실제 주소를 찾기 위해 메모리 내의 데이터를 한 번 더 인출하는 과정을 의미합니다.
    4. 인터럽트 사이클은 프로그램의 순차적인 흐름을 이어나가게 합니다.
    - 정답: 4번
- #2. 인터럽트에 대한 설명으로 옳지 않은 것을 고르세요.
    1. 인터럽트는 프로그램의 정상적인 실행 흐름을 방해하는 기능입니다.
    2. CPU는 입출력 작업 도중에도 명령어를 효율적으로 처리하기 위해 하드웨어 인터럽트를 사용할 수 있습니다.
    3. 모든 인터럽트는 인터럽트 비트를 설정함으로써 막을 수 있습니다.
    4. CPU는 인터럽트를 처리하기 위해 인터럽트 서비스 루틴을 수행합니다. 
    - 정답: 3번
- #3. 다음 빈칸에 알맞은 말을 〈보기〉에서 찾아 써 보세요.
    
    > `보기` 인터럽트 서비스 루틴, 인터럽트 벡터, 인터럽트 요청 신호
    > 
    - CPU는 인터럽트를 처리하기 위해 하던 작업을 잠시 백업한 뒤 (     )라는 프로그램을 실행합니다.
    - 정답: 인터럽트 서비스 루틴
- #4. 명령어 사이클에서 인출 사이클에 대한 설명으로 옳은 것을 고르세요.
    1. CPU가 명령어를 실행하는 단계입니다.
    2. CPU가 명령어를 메모리로부터 가져오는 단계입니다. 
    3. 예기치 못한 상황에 대처하는 단계입니다.
    4. CPU가 작동을 멈추는 단계입니다.
    - 정답: 2번
- #5. CPU가 프로그램을 실행하던 도중 하드웨어 인터럽트가 발생했습니다. 이때 CPU가 수행할 동작으로 올바른 것을 고르세요(플래그 레지스터 속 인터럽트 비트는 활성화되어 있다고 가정하겠습니다).
    1. 프로그램을 종료합니다.
    2. 인터럽트를 처리하기 전에 실행하던 프로그램을 마저 실행합니다.
    3. 수행하던 작업을 잠시 백업한 뒤 인터럽트 서비스 루틴을 실행하고 다시 수행하던 작업으로 되돌아옵니다.
    4. 보조기억장치에 저장된 정보를 초기화합니다.
    - 정답: 3번
