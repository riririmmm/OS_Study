## 03-1. 소스 코드와 명령어

- **고급 언어**: 사람을 위한 언어
    - 대부분의 프로그래밍 언어
    - 저급 언어로 변환되어 실행
- **저급 언어**: 컴퓨터가 직접 이해 & 실행 가능한 언어
    - 명령어로 이루어짐
    - 저급 언어 = 기계어 or 어셈블리어
    - **기계어**: 0과 1의 명령어 비트로 이루어진 언어
    - **어셈블리어**: 기계어를 읽기 편한 형태로 번역한 언어
- **컴파일 언어**: 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어
    - ex) C언어
    - **컴파일**: 작성된 소스 코드를 저급 언어로 변환하는 과정
    - **컴파일러**: 컴파일을 수행해 주는 도구
    - **목적 코드**: 컴파일러를 통해 저급 언어로 변환된 코드
- **인터프리터 언어**: 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어
    - ex) python
    - **인터프리터**: 소스 코드를 한 줄씩 저급 언어로 변환 & 실행해 주는 도구
    - 오류 전의 코드까지는 실행됨
    - 컴파일 언어보다 느림
- **목적 파일**: 목적 코드로 이루어진 파일
    - 목적 코드 → 실행 파일 변환 위해 링킹이라는 작업 필요

### 확인 문제

- #1. 다음 중 고급 언어가 아닌 것을 모두 고르세요.
    1. 컴파일 언어
    2. 인터프리터 언어
    3. 기계어
    4. 어셈블리 언어
    - 정답: 3번, 4번
- #2. 다음 중 옳지 않은 것을 고르세요.
    1. 컴파일 언어는 한 줄이라도 소스 코드상에 오류가 있다면 실행될 수 없습니다.
    2. 일반적으로 컴파일 언어보다 인터프리터 언어가 더 빠릅니다.
    3. 인터프리터는 인터프리터 언어로 작성된 소스 코드를 한 줄씩 저급 언어로 변환하여 실행합니다.
    4. 컴파일러는 컴파일 언어로 작성된 소스 코드 전체를 목적 코드로 변환합니다.
    - 정답: 2번

## 03-2. 명령어의 구조

- **명령어**: 연산 코드 + 오퍼랜드
    - **연산 코드**(연산자): 명령어가 수행할 연산
    - **오퍼랜드**(피연산자): 연산에 사용할 데이터가 저장된 위치
- 오퍼랜드
    - **오퍼랜드 필드**(주소 필드): 오퍼랜드가 담기는 영역
    - n-주소 명령어: 오퍼랜드가 n개인 명령어
- 연산 코드
    - 연산 코드 유형: 데이터 전송 / 산술논리 연산 / 제어 흐름 변경 / 입출력 제어
    - 데이터 전송
        - MOVE: 데이터를 옮겨라
        - STORE: 메모리에 저장하라
        - LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라
        - PUSH: 스택에 데이터를 저장하라
        - POP: 스택의 최상단 데이터를 가져와라
    - 산술/논리 연산
        - ADD / SUBTRACT / MULTIPLY / DIVIDE: 덧셈 / 뺄셈 / 곱셈 / 나눗셈 수행
        - INCREMENT / DECREMENT: 오퍼랜드에 1을 더하라 / 빼라
        - AND / OR / NOT: AND / OR / NOT 연산을 수행하라
        - COMPARE: 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라
    - 제어 흐름 변경
        - JUMP: 특정 주소로 실행 순서를 옮겨라
        - CONDITIONAL JUMP: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
        - HALT: 프로그램 실행 중지
        - CALL: 되돌아올 주소 저장한 채 특정 주소로 실행 순서 옮겨라
        - RETURN: CALL 호출 시 저장했던 주소로 돌오가라
    - 입출력 제어
        - READ(INPUT): 특정 입출력 장치로부터 테이터를 읽어라
        - WRITE(OUTPUT): 특정 입출력 장치로 데이터를 써라
        - START IO: 입출력 장치 시작
        - TEST IO: 입출력 장치 상태 확인
- **유효 주소**: 연산 코드에 사용할 데이터가 저장된 위치
- **주소 지정 방식**: 연산에 사용할 데이터(유효 주소)를 찾는 방법
    - 즉시 주소 지정 방식 / 직접 주소 지정 방식 / 간접 주소 지정 방식 / 레지스터 주소 지정 방식 / 레지스터 간접 주소 지정 방식
- **즉시 주소 지정 방식**
    - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
    - 장점: 빠름
    - 단점: 표현 가능한 데이터 크기 감소
    
    | 연산 코드 | 연산에 사용할 데이터 |
    | --- | --- |
- **직접 주소 지정 방식**
    - 오퍼랜드 필드에 유효 주소를 직접적으로 명시
    - 유효 주소 표현 가능한 범위 적음
    
    <img width=65% src="https://github.com/user-attachments/assets/ba20a246-1a1e-4626-90f6-712eb7598dd6" />
    
- **레지스터 주소 지정 방식**
    - 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
    - CPU 외부 메모리 접근보다 CPU 내부 레지스터 접근이 빠름 
    → 직접 주소 지정 방식보다 빠르게 데이터 접근 가능
    - 단점: 표현 가능한 레지스터 크기에 제한
    
    <img width=65% alt="Image" src="https://github.com/user-attachments/assets/b348e6ec-0ac7-44a6-94e1-7e2e52df2ddd" />
    
- **레지스터 간접 주소 지정 방식**
    - 연산에 사용할 데이터를 메모리에 저장, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시
    - 메모리 접근 한 번
    - 간접 주소 지정 방식보다 빠름
    
    <img width=65% alt="image" src="https://github.com/user-attachments/assets/47c5b170-230e-4311-b134-7c450140121b" />

    

### 확인 문제

- #1. 명령어에 대한 설명 중 옳지 않은 것은?
    1. 명령어는 연산 코드와 오퍼랜드로 구성됩니다.
    2. 연산 코드 필드에는 메모리 주소만 담을 수 있습니다.
    3. 오퍼랜드 필드는 여러 개 있을 수 있습니다.
    4. 명령어에 연산에 사용할 데이터를 직접 명시할 경우 표현할 수 있는 데이터의 크기는 연산 코드의 크기만큼 작아집니다.
    - 정답: 2번
- #2. 아래 그림 속 CPU에는 R1, R2라는 레지스터가 있고, 메모리 5번지에 100, 6번지에 200, 7번지에 300이 저장되어 있습니다. 아래 명령어를 레지스터 간접 주소 지정 방식으로 수행한다면 결과는 어떻게 나올까요? 아래 빈칸을 채워 보세요.
    
    > 메모리 (   ①   )번지 속 (   ②   )이라는 값을 CPU로 가지고 온다.
    > 
    
    <img width=65% alt="image" src="https://github.com/user-attachments/assets/fef25ed8-4a53-474a-9460-a62619998222" />

    
    - 정답: 6, 200
